<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>食品腐败条带检测 · Web 版 Demo</title>
<style>
  body { font-family: Arial, sans-serif; margin:0; padding:0; background:#0b1020; color:#e5e7eb; }
  header { padding:16px; background:#11172a; border-bottom:1px solid #1f253a; position:sticky; top:0; }
  h1 { font-size:20px; margin:0; }
  main { max-width:960px; margin:0 auto; padding:16px; }
  .card { background:#11172a; border:1px solid #1f253a; border-radius:12px; padding:14px; margin-bottom:18px; }
  canvas { width:100%; height:auto; background:#0a0f1f; border-radius:10px; }
  .btn { padding:8px 14px; background:#4f8cff; color:#fff; border:none; border-radius:8px; cursor:pointer; margin:4px 2px; }
  .btn:disabled { opacity:0.5; cursor:not-allowed; }
  label { display:inline-block; width:90px; font-size:13px; color:#9ca3af; }
  input[type=range], input[type=text], input[type=number] { width:100%; }
  .grid { display:grid; grid-template-columns:1fr 1fr; gap:8px; }
  .mono { font-family: monospace; }
</style>
</head>
<body>
<header><h1>食品腐败条带检测 · Web Demo</h1></header>
<main>
  <div class="card">
    <h3>1) 上传或拍照</h3>
    <div class="grid">
      <input id="file" type="file" accept="image/*" />
      <input id="camera" type="file" accept="image/*" capture="environment" />
    </div>
    <canvas id="cv" width="960" height="720"></canvas>
    <p style="font-size:13px;color:#9ca3af">蓝框=标准条带 ROI，绿框=反应区 ROI</p>
  </div>

  <div class="card">
    <h3>2) 参数</h3>
    <div>
      <label>std X%</label><input id="stdx" type="range" min="0" max="100" value="5"><br>
      <label>std Y%</label><input id="stdy" type="range" min="0" max="100" value="15"><br>
      <label>std W%</label><input id="stdw" type="range" min="5" max="60" value="15"><br>
      <label>std H%</label><input id="stdh" type="range" min="10" max="90" value="70"><br>
      <label>test X%</label><input id="tstx" type="range" min="0" max="100" value="55"><br>
      <label>test Y%</label><input id="tsty" type="range" min="0" max="100" value="35"><br>
      <label>test W%</label><input id="tstw" type="range" min="10" max="90" value="35"><br>
      <label>test H%</label><input id="tsth" type="range" min="10" max="90" value="30"><br>
      <label>切片数</label><input id="slices" type="number" value="8"><br>
      <label>等级数组</label><input id="levels" type="text" value="0,0.14,0.28,0.42,0.56,0.70,0.84,1.0"><br>
      <label>映射 a</label><input id="mapa" type="number" value="100"><br>
      <label>映射 b</label><input id="mapb" type="number" value="0"><br>
      <label>单位</label><input id="unit" type="text" value="AU"><br>
    </div>
    <button class="btn" id="btnCompute" disabled>计算浓度</button>
  </div>

  <div class="card">
    <h3>3) 结果</h3>
    <div>反应区灰度：<span class="mono" id="valGray">-</span></div>
    <div>等级 Level：<span class="mono" id="valLevel">-</span></div>
    <div>估算浓度：<span class="mono" id="valConc">-</span></div>
    <div class="mono" id="valModel">-</div>
  </div>
</main>

<script>
// --- 工具函数 ---
const $=id=>document.getElementById(id);
const toGray=(r,g,b)=>Math.round(0.299*r+0.587*g+0.114*b);

function drawROI(ctx,w,h,roi,color){
  ctx.strokeStyle=color; ctx.lineWidth=3;
  ctx.strokeRect(Math.round(roi.x*w),Math.round(roi.y*h),Math.round(roi.w*w),Math.round(roi.h*h));
}

function sliceVerticalMeans(imgData,slices){
  const {width:w,height:h,data:d}=imgData;
  const sliceH=Math.floor(h/slices);
  const means=[];
  for(let s=0;s<slices;s++){
    const y0=s*sliceH,y1=(s===slices-1?h:(s+1)*sliceH);
    let sum=0,n=0;
    for(let y=y0;y<y1;y++){
      for(let x=0;x<w;x++){
        const i=(y*w+x)*4;
        sum+=toGray(d[i],d[i+1],d[i+2]); n++;
      }
    }
    means.push(sum/n);
  }
  return means;
}
function meanGray(imgData){
  const d=imgData.data;let sum=0,n=0;
  for(let i=0;i<d.length;i+=4){ sum+=toGray(d[i],d[i+1],d[i+2]); n++; }
  return sum/n;
}
function fitGrayToLevel(stdGray,stdLevels){
  const n=Math.min(stdGray.length,stdLevels.length);
  let sumx=0,sumy=0,sumxx=0,sumxy=0;
  for(let i=0;i<n;i++){const x=stdGray[i],y=stdLevels[i];sumx+=x;sumy+=y;sumxx+=x*x;sumxy+=x*y;}
  const denom=n*sumxx-sumx*sumx;
  const p=denom===0?0:(n*sumxy-sumx*sumy)/denom;
  const q=(sumy-p*sumx)/n;
  return {p,q};
}
function clamp(v,lo,hi){return Math.max(lo,Math.min(hi,v));}

// --- 画布 ---
const canvas=$('cv'); const ctx=canvas.getContext('2d');
let img=new Image(), imgW=0,imgH=0, hasImage=false;
const state={std:{x:0.05,y:0.15,w:0.15,h:0.7},test:{x:0.55,y:0.35,w:0.35,h:0.3}};

function redraw(){
  if(!hasImage)return;
  const scale=Math.min(1,960/img.naturalWidth);
  imgW=Math.round(img.naturalWidth*scale); imgH=Math.round(img.naturalHeight*scale);
  canvas.width=imgW; canvas.height=imgH;
  ctx.drawImage(img,0,0,imgW,imgH);
  drawROI(ctx,imgW,imgH,state.std,'blue');
  drawROI(ctx,imgW,imgH,state.test,'green');
}
function handleFiles(files){
  if(!files||!files.length)return;
  const url=URL.createObjectURL(files[0]);
  img.onload=()=>{hasImage=true;$('btnCompute').disabled=false;redraw();URL.revokeObjectURL(url);};
  img.src=url;
}
$('file').addEventListener('change',e=>handleFiles(e.target.files));
$('camera').addEventListener('change',e=>handleFiles(e.target.files));

// --- 计算 ---
$('btnCompute').addEventListener('click',()=>{
  if(!hasImage)return;
  state.std.x=+$('stdx').value/100; state.std.y=+$('stdy').value/100;
  state.std.w=+$('stdw').value/100; state.std.h=+$('stdh').value/100;
  state.test.x=+$('tstx').value/100; state.test.y=+$('tsty').value/100;
  state.test.w=+$('tstw').value/100; state.test.h=+$('tsth').value/100;
  const slices=+$('slices').value;
  const levels=$('levels').value.split(',').map(v=>+v.trim());
  const a=+$('mapa').value,b=+$('mapb').value,unit=$('unit').value||'AU';

  const rx=x=>Math.round(x*imgW), ry=y=>Math.round(y*imgH);
  const stdData=ctx.getImageData(rx(state.std.x),ry(state.std.y),rx(state.std.w),ry(state.std.h));
  const testData=ctx.getImageData(rx(state.test.x),ry(state.test.y),rx(state.test.w),ry(state.test.h));

  const stdMeans=sliceVerticalMeans(stdData,slices);
  const model=fitGrayToLevel(stdMeans,levels);
  const gTest=meanGray(testData);
  let level=model.p*gTest+model.q; level=clamp(level,0,1);
  const conc=a*level+b;

  $('valGray').textContent=Math.round(gTest);
  $('valLevel').textContent=level.toFixed(3);
  $('valConc').textContent=conc.toFixed(2)+' '+unit;
  $('valModel').textContent=`回归: level=${model.p.toFixed(6)}*gray+${model.q.toFixed(6)}`;
});
</script>
</body>
</html>
